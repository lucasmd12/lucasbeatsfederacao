// Removed Firestore import
import '../models/mission_model.dart';
import '../services/api_service.dart'; // Import ApiService
import '../utils/logger.dart'; // Use Logger

class MissionService {
  final ApiService _apiService; // Inject ApiService

  MissionService(this._apiService);

  // Criar nova missão (POST /api/missions)
  Future<MissionModel?> createMission(MissionModel mission) async {
    try {
      // Assuming mission ID might be generated by backend or frontend
      // If generated by backend, the response should contain the full mission data including ID
      // Corrected: Use toMap instead of toJson
      final response = await _apiService.post('/api/missions', mission.toMap());
      if (response != null) {
        Logger.info('Missão criada com sucesso via API.');
        // Corrected: Use fromMap instead of fromJson
        return MissionModel.fromMap(response); // Return the created mission from response
      } else {
        Logger.warning('API não retornou dados ao criar missão.');
        return null;
      }
    } catch (e, s) {
      Logger.error('Erro ao criar missão via API', error: e, stackTrace: s);
      // Re-throw a more specific exception or return null
      throw Exception('Falha ao criar missão: ${e.toString()}');
    }
  }

  // Obter todas as missões (GET /api/missions)
  // Changed from Stream to Future
  Future<List<MissionModel>> getMissions() async {
    try {
      final response = await _apiService.get('/api/missions'); // Adjust endpoint if needed
      if (response != null && response is List) {
        // Corrected: Use fromMap instead of fromJson
        final missions = response.map((data) => MissionModel.fromMap(data)).toList();
        Logger.info('Buscou ${missions.length} missões via API.');
        return missions;
      } else {
        Logger.warning('API não retornou lista de missões ou formato inválido.');
        return [];
      }
    } catch (e, s) {
      Logger.error('Erro ao buscar missões via API', error: e, stackTrace: s);
      return []; // Return empty list on error
    }
  }

  // Obter missões de um usuário específico (GET /api/users/{userId}/missions or /api/missions?userId={userId})
  // Changed from Stream to Future
  Future<List<MissionModel>> getUserMissions(String userId) async {
    try {
      // Adjust endpoint based on your API design
      final response = await _apiService.get('/api/users/$userId/missions');
      if (response != null && response is List) {
        // Corrected: Use fromMap instead of fromJson
        final missions = response.map((data) => MissionModel.fromMap(data)).toList();
        Logger.info('Buscou ${missions.length} missões para o usuário $userId via API.');
        return missions;
      } else {
        Logger.warning('API não retornou lista de missões do usuário ou formato inválido.');
        return [];
      }
    } catch (e, s) {
      Logger.error('Erro ao buscar missões do usuário $userId via API', error: e, stackTrace: s);
      return [];
    }
  }

  // Atualizar missão (PUT /api/missions/{missionId})
  Future<bool> updateMission(String missionId, Map<String, dynamic> updateData) async {
    try {
      final response = await _apiService.put('/api/missions/$missionId', updateData);
      // Check response status or content to confirm success
      final success = response != null; // Basic check, adjust as needed
      if (success) {
        Logger.info('Missão $missionId atualizada com sucesso via API.');
      } else {
        Logger.warning('Falha ao atualizar missão $missionId via API.');
      }
      return success;
    } catch (e, s) {
      Logger.error('Erro ao atualizar missão $missionId via API', error: e, stackTrace: s);
      return false;
    }
  }

  // Excluir missão (DELETE /api/missions/{missionId})
  Future<bool> deleteMission(String missionId) async {
    try {
      final response = await _apiService.delete('/api/missions/$missionId');
      // Check response status or content to confirm success
      final success = response != null; // Basic check, adjust as needed
      if (success) {
        Logger.info('Missão $missionId excluída com sucesso via API.');
      } else {
        Logger.warning('Falha ao excluir missão $missionId via API.');
      }
      return success;
    } catch (e, s) {
      Logger.error('Erro ao excluir missão $missionId via API', error: e, stackTrace: s);
      return false;
    }
  }

  // Atualizar status da missão (PATCH /api/missions/{missionId}/status or PUT)
  Future<bool> updateMissionStatus(String missionId, String status) async {
    try {
      // Use PATCH for partial update if API supports it
      final response = await _apiService.patch('/api/missions/$missionId', {'status': status});
      final success = response != null;
      if (success) {
        Logger.info('Status da missão $missionId atualizado para $status via API.');
      } else {
        Logger.warning('Falha ao atualizar status da missão $missionId via API.');
      }
      return success;
    } catch (e, s) {
      Logger.error('Erro ao atualizar status da missão $missionId via API', error: e, stackTrace: s);
      return false;
    }
  }

  // Atribuir missão a usuários (PUT /api/missions/{missionId}/assign or similar)
  Future<bool> assignMissionToUsers(String missionId, List<String> userIds) async {
    try {
      // Endpoint might be different, e.g., PUT /api/missions/{missionId}
      final response = await _apiService.put('/api/missions/$missionId/assign', {'userIds': userIds});
      final success = response != null;
      if (success) {
        Logger.info('Missão $missionId atribuída aos usuários via API.');
      } else {
        Logger.warning('Falha ao atribuir missão $missionId via API.');
      }
      return success;
    } catch (e, s) {
      Logger.error('Erro ao atribuir missão $missionId via API', error: e, stackTrace: s);
      return false;
    }
  }
}

